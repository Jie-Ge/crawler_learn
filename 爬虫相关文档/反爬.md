
 ## 如何看出是哪种加密？
- Base64加密
    - 特点：由 ‘A-Z、a-z、0-9、+、_、=’ 组成；一般是 1 个或2个 '=' 结尾；是一种编码，可直接还原成明文
        - 例如: bmV0ZHolNDBzaW5hLmNvbQ=
    - python实现
    ```python
        import base64
        
        s = 'hello, world'
        s = "你好"
        # 加密
        bs = base64.b64encode(s.encode("utf8"))
        print(bs)
        
        # 解密
        decode = base64.b64decode(bs)
        print(decode)
        print(decode.decode("utf8"))
    ```

## 1、md5 加密
- md5一旦加密，数据就不能返回成原来的值了，是不可以解密的
```python
import hashlib
## ====================== bv
str1 = 'this is a sentence'

# 1、创建hash对象
hl = hashlib.md5()

# 2、向hash对象中添加需要做hash运算的字符串
hl.update(str1.encode('utf-8'))  # 这个地方传的是bytes类型的数据，否则会报错

# 3、获取字符串的hash值
bv = hl.hexdigest()


### 或者只需要一句代码
str1_md5 = hashlib.md5(str1.encode(encoding='utf-8')).hexdigest()
```

- 加密后的样式（不管被加密字符串有多长）
    - 用16位 小写	：f8ed5d21a44b0e58
    - 用16位 大写	：F8ED5D21A44B0E58
    - 用32位 小写	：b6d767d2f8ed5d21a44b0e5886680cb9
    - 用32位 大写	：B6D767D2F8ED5D21A44B0E5886680CB9

## 2、RSA 加密
RSA生成公钥私钥、加密、解密、加签、验签，通常使用公钥加密，私钥解密，私钥签名，公钥验签

## 3、DES加密（可带模值iv）
- python实现
```python
from Crypto.Cipher import DES

key = b'abcdefgh'  # 密钥 8位或16位,必须为bytes
def pad(text):
    """
    # 加密函数，如果text不是8的倍数【加密文本text必须为8的倍数！】，那就补足为8的倍数
    :param text:
    :return:
    """
    while len(text) % 8 != 0:
        text += ' '
    return text

des = DES.new(key, DES.MODE_ECB)  # 创建一个DES实例
text = 'Python rocks!'
padded_text = pad(text)
encrypted_text = des.encrypt(padded_text.encode('utf-8'))  # 加密
print(encrypted_text)
# rstrip(' ')返回从字符串末尾删除所有字符串的字符串(默认空白字符)的副本
plain_text = des.decrypt(encrypted_text).decode().rstrip(' ')  # 解密
print(plain_text)
```

## 4、AES加密（可带模值iv）
- python实现
```python
from Crypto.Cipher import AES
def to_16(data):
    pad = 16 - len(data) % 16
    data += chr(pad) * pad
    return data
key = 'this is a 16 key'
data = 'aswasdwasasda' # 待加密数据
iv = '0102030405060708'
# key = 'abcdefgh'  # 密钥key必须为 16（AES-128）， 24（AES-192）， 32（AES-256）,必须为bytes
# mode: 模式，先看m3u8文件是否提示用的什么模式，没有的话就一个一个的试
# IV：偏移量，字节型，位数与key相同
aes = AES.new(key=key.encode('utf-8'), IV=iv.encode('utf-8'), mode=AES.MODE_CBC)  # 创建加密器

# 加密的内容长度必须是16的倍数【长度刚好是16也是需要加上chr(需要补齐的位数)进行补齐,不够要补，够了也要补】
# chr()返回值是当前整数对应的 ASCII 字符
# 如：'123456789abcde'，差1位，则需要1个chr(1)补齐成这样：'123456789abcdechr(1)'
# 如：'123456789abc'，差4位，则需要4个chr(4)补齐成这样：'123456789abcchr(4)chr(4)chr(4)chr(4)'
# 如：'123456789abcdef'，刚好16位，则需要16个chr(16)补齐成这样：'123456789abcdefchr(16)。。。chr(16)'
data = to_16(data)

# byte类型数据
data_byte = aes.encrypt(data.encode('utf-8'))  # 加密
```

## 5、懒加载
- 懒加载：网页懒加载是前端为了提高网页访问速度，将页面内没有出现在可视区域内的图片先不做加载，等到手动滑动鼠标滚动到可视区域后再加载。
        这样对于网页加载性能上会有很大的提升，懒加载的效果就可以提升用户体验。
- 爬取思路： 
        网页中包含大量的图片，如果一次性全部加载，页面会因为请求过多造成卡顿，并且对服务器也会造成压力，
        那么程序员可以将图片的src属性设置成伪属性，一般设置为src2，名称可以任意设定，这样网页在加载的时候不会去请求显示图片，
        当用户滚动到该区域时，在通过JS动态修改属性名为src，实现图片加载。  
    这种思路最终设定不是为了反爬，单纯为了优化页面加载速度，但只要影响到我们去爬取内容，那一概打入反爬套路中。
  
## 6、js混淆
![img.png](js混淆.png)
- 【参考】https://www.cnblogs.com/zyyhxbs/p/11663522.html
- js混淆: 我们会惊讶的发现getServerData后面跟的是什么鬼啊?不符合js函数定义的写法呀!看不懂呀!其实这里是经过 JavaScript 混淆加密了（将js代码加密）,
  混淆加密之后,代码将变为人不可读的形式,但是功能是完全一致的,这是一种常见的 JavaScript 加密手段.我们想要查看到该方法的原始实现则必须对其进行反混淆.
- js反混淆: 
    - js 混淆之后,其实是有反混淆方法的,最简单的方法便是搜索在线反混淆网站,例如 http://www.bm8.com.cn/jsConfusion/ ,
        将getServerData存在的这行数据粘贴到反混淆网站中。
    - 其他方法：https://blog.csdn.net/qq_42771415/article/details/105046689

## 7、APP混淆
- 请看 '手机APP数据（抓包）.md'

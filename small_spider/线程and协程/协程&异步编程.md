## 1 协程
- 协程不是计算机提供，程序员人为创造
- 协程，也可称为微线程，就是通过一个线程实现代码块相互切换执行
- 实现协程的几种方法：
    - greenlet, 早期模块
    - yield关键字
    - asyncio装饰器（py3.4）
    - async, await关键字（py3.5）【推荐】
- 怎么使用：在需要等待的语句前加上异步关键字  
- 协程意义：在一个线程中如果遇到io等待，线程不会傻傻等待，会执行下一个任务【异步】

## 2 异步编程
- 【异步】：在一个线程中如果遇到io等待，线程不会傻傻等待，会执行下一个任务
### 2.1 快速上手
- 协程函数：`async def 函数名`
- 协程对象：执行协程函数得到的协程对象
```python
import asyncio
async def func():
  print("我被执行了！！！")

result = func()  # 创建协程对象，函数内部代码不会执行

# # 生成或获取一个事件循环
# loop = asyncio.get_event_loop()
# # 循环执行任务
# loop.run_until_complete(result)
# 上面两句等价于下面的执行语句
asyncio.run(result)  # python3.7
```
    
### 2.2 await
- await + 可等待的对象（协程对象、Future、Task对象）
- 等待执行完之后再继续往下走
```python
import asyncio

async def others():
  print('start......')
  await asyncio.sleep(2)
  print('end')
  return '返回值'

async def func():
    print('func()......')
    # 此示例中，需等待执行完后才会继续执行后面的代码，非异步 【与下一段的代码区分】
    response1 = await others()  
    print(response1)
    response2 = await others()
    print(response2)
    
asyncio.run(func())
```

### 2.3 Task
- 在事件循环中添加多个任务
- 通过 `asyncio.create_task(协程对象)` 的方式创建Task对象，还可以用低层级的`loop.create_task()`或者`asyncio.ensure_future()`
- 【注意】`asyncio.create_task(协程对象)`是在python3.7中加入的
```python
import asyncio

async def others():
  print('start......')
  await asyncio.sleep(2)
  print('end')
  return '返回值'

async def func():
    print('func()......')
    # 创建了两个任务
    task1 = asyncio.create_task(others())
    task2 = asyncio.create_task(others())
    
    # 此实例中，因为有两个任务，所以 await task1 遇到io等待时，会切换到执行 await task2 【与上一段的代码区分】
    ret1 = await task1
    ret2 = await task2
    
asyncio.run(func())
```

实际中应该这样写：
```python
import asyncio

async def others():
  print('start......')
  await asyncio.sleep(2)
  print('end')
  return '返回值'

async def func():
    print('func()......')
    # 创建任务列表
    task_list = [
        asyncio.create_task(others(), name='n1'),
        asyncio.create_task(others(), name='n2')
    ]
    # done存储所有的任务相关信息，pending没啥用
    done, pending = await asyncio.wait(task_list)
    
asyncio.run(func())
```

若任务没有在协程函数里面，应该这样写：
```python
import asyncio

async def others():
  print('start......')
  await asyncio.sleep(2)
  print('end')
  return '返回值'


task_list = [
    others(),
    others()
]
# done存储所有的任务相关信息，pending没啥用
done, pending = asyncio.run( asyncio.wait(task_list) )

```

### 2.4 异步与非异步

### 2.5 异步迭代器

### 2.6 异步上下文管理器（打开、关闭操作）
- 类中定义__aenter__()和__aexit__()方法，并结合async with来使用
- 作用：可使用在需要打开、关闭的操作中 (如连接、关闭数据库)
```python
import asyncio

class AsyncContextManager:
    def __init__(self):
        self.conn = conn
    async def do_something(self):
      # 异步操作数据库
        return 666
    async def __aenter__(self):
      # 异步连接数据库
        self.conn = await asyncio.sleep(1)
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        # 异步关闭数据库连接
        await asyncio.sleep(1)

# async with 必须放在协程函数里
async def func():
    # async with 类似于文件操作中with
    # 当进入时，调用__aenter__()；当结束时，调用__aexit__()
    async with AsyncContextManager() as f:
        result = await f.do_something()
        print(result)
        
asyncio.run(func())
```

## 3 uvloop模块
- 是asyncio事件循环的替代方案，事件循环的性能和效率 > asyncio事件循环，接近go语言
```python
import uvloop
import asyncio

# 只需在开头将asyncio事件循环切换成uvloop事件循环
asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())

# 其他代码与asyncio代码一致
```

## 4 案例
### 4.1 异步 redis
- 在使用python操作redis时，连接/操作/断开 都是网络IO，可异步操作
- 需要用到 aioredis 模块
```python
import aioredis
import asyncio
async def execute(address, password):
  
    # 网络IO操作，遇到IO会自动切换任务
    redis = await aioredis.create_redis_pool(address, password)
    
    # 网络IO操作，遇到IO会自动切换任务
    # 插入哈希键值对
    await redis.hmset_dict('car', key1=1, key2=2)
    
    # 网络IO操作，遇到IO会自动切换任务
    result = await redis.hgetall('car', encoding='utf-8')
    
    # 网络IO操作，遇到IO会自动切换任务
    redis.close()
    await redis.wait_closed()

task_list = [
  execute('redis://47.23.4.123:6397', 'qwert'),
  execute('redis://47.23.4.334:6397', 'qwert')
]

asyncio.run(asyncio.wait(task_list))
```

### 4.2 异步 MySql
- 【同】与 异步redis 思想相同
- 需要用到 aiomysql 模块

### 4.3 FastAPI
- FastAPI 是基于python的高性能的web框架